"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWithRouter = exports.createUseRouter = void 0;
var pathToRegexpModule = require("path-to-regexp");
var cache = {};
var router = {
    history: null,
    handles: [],
    errorHandler: function () { },
    addHandle: function (handle) {
        return router.handles.push(handle);
    },
    removeHandle: function (handleId) {
        router.handles[handleId - 1] = null;
    },
    triggerHandles: function (component) {
        router.handles.forEach(function (handle) {
            if (handle) {
                handle(component);
            }
        });
    },
    match: function (fullpath) {
        if (fullpath == null)
            return;
        router.fullpath = fullpath;
        var parent = router.root;
        // @ts-ignore
        var matched = matchRoute(parent, parent.path, fullpath);
        // eslint-disable-next-line
        function next(parent) {
            var current = matched.next();
            if (current.done) {
                var error = new Error("No match for " + fullpath);
                // @ts-ignore
                return router.errorHandler(error, router.history.location);
            }
            var component = current.$.route.component;
            if (typeof component === 'function') {
                component = component(current.$.params, router.history.location);
            }
            if (component instanceof Promise) {
                // Lazy loading component by import('./Foo')
                // eslint-disable-next-line
                return component.then(function (component) {
                    // Check current fullpath avoid router has changed before lazy loading complete
                    // @ts-ignore
                    if (fullpath === router.fullpath) {
                        router.triggerHandles(component);
                    }
                });
            }
            else if (component != null) {
                router.triggerHandles(component);
                return component;
            }
            else {
                return next(parent);
            }
        }
        return next(parent);
    }
};
function decodeParam(val) {
    try {
        return decodeURIComponent(val);
    }
    catch (err) {
        return val;
    }
}
function matchLocation(_a) {
    var pathname = _a.pathname;
    router.match(pathname);
}
function matchPath(route, pathname, parentParams) {
    // eslint-disable-next-line
    var path = route.path, routes = route.routes, _a = route.exact, end = _a === void 0 ? true : _a, _b = route.strict, strict = _b === void 0 ? false : _b, _c = route.sensitive, sensitive = _c === void 0 ? false : _c;
    // If not has path or has routes that should do not exact match
    if (path == null || routes) {
        end = false;
    }
    // Default path is empty
    path = path || '';
    var regexpCacheKey = path + "|" + end + "|" + strict + "|" + sensitive;
    var keysCacheKey = regexpCacheKey + "|";
    var regexp = cache[regexpCacheKey];
    var keys = cache[keysCacheKey] || [];
    if (!regexp) {
        regexp = pathToRegexpModule.pathToRegexp(path, keys, {
            end: end,
            strict: strict,
            sensitive: sensitive
        });
        cache[regexpCacheKey] = regexp;
        cache[keysCacheKey] = keys;
    }
    var result = regexp.exec(pathname);
    if (!result) {
        return null;
    }
    var url = result[0];
    var params = __assign(__assign({}, parentParams), { history: router.history, location: router.history.location });
    for (var i = 1; i < result.length; i++) {
        var key = keys[i - 1];
        var prop = key.name;
        var value = result[i];
        if (value !== undefined || !Object.prototype.hasOwnProperty.call(params, prop)) {
            if (key.repeat) {
                params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
            }
            else {
                params[prop] = value ? decodeParam(value) : value;
            }
        }
    }
    return {
        path: !end && url.charAt(url.length - 1) === '/' ? url.substr(1) : url,
        params: params,
    };
}
function matchRoute(route, baseUrl, pathname, parentParams) {
    var matched;
    var childMatches;
    var childIndex = 0;
    return {
        next: function () {
            if (!matched) {
                matched = matchPath(route, pathname, parentParams);
                if (matched) {
                    return {
                        done: false,
                        $: {
                            route: route,
                            baseUrl: baseUrl,
                            path: matched.path,
                            params: matched.params,
                        },
                    };
                }
            }
            if (matched && route.routes) {
                while (childIndex < route.routes.length) {
                    if (!childMatches) {
                        var childRoute = route.routes[childIndex];
                        childRoute.parent = route;
                        childMatches = matchRoute(childRoute, baseUrl + matched.path, pathname.substr(matched.path.length), matched.params);
                    }
                    var childMatch = childMatches.next();
                    if (!childMatch.done) {
                        return {
                            done: false,
                            $: childMatch.$,
                        };
                    }
                    childMatches = null;
                    childIndex++;
                }
            }
            return { done: true };
        },
    };
}
function getInitialComponent(routerConfig) {
    var InitialComponent = [];
    if (process.env.NODE_ENV !== 'production') {
        if (!routerConfig) {
            throw new Error('Error: useRouter should have routerConfig.');
        }
        if (!routerConfig.history || !routerConfig.routes) {
            throw new Error('Error: routerConfig should contain history and routes.');
        }
    }
    if (routerConfig.InitialComponent) {
        InitialComponent = routerConfig.InitialComponent;
    }
    router.history = routerConfig.history;
    return InitialComponent;
}
function createUseRouter(api) {
    var useState = api.useState, useLayoutEffect = api.useLayoutEffect;
    function useRouter(routerConfig) {
        var _a = useState(getInitialComponent(routerConfig)), component = _a[0], setComponent = _a[1];
        useLayoutEffect(function () {
            var history = routerConfig.history;
            var routes = routerConfig.routes;
            // @ts-ignore
            router.root = Array.isArray(routes) ? { routes: routes } : routes;
            // eslint-disable-next-line
            var handleId = router.addHandle(function (component) {
                setComponent(component);
            });
            // Init path match
            if (!routerConfig.InitialComponent) {
                matchLocation(history.location);
            }
            var unlisten = history.listen(function (location) {
                matchLocation(location);
            });
            return function () {
                router.removeHandle(handleId);
                unlisten();
            };
        }, [routerConfig]);
        return { component: component };
    }
    return useRouter;
}
exports.createUseRouter = createUseRouter;
function createWithRouter(api) {
    var createElement = api.createElement;
    function withRouter(Component) {
        function Wrapper(props) {
            var history = router.history;
            return createElement(Component, __assign(__assign({}, props), { history: history, location: history.location }));
        }
        Wrapper.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
        Wrapper.WrappedComponent = Component;
        return Wrapper;
    }
    return withRouter;
}
exports.createWithRouter = createWithRouter;
