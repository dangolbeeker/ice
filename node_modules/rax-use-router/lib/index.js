"use strict";

exports.__esModule = true;
exports.useRouter = useRouter;
exports.withRouter = withRouter;

var _rax = require("rax");

var _pathToRegexp = _interopRequireDefault(require("path-to-regexp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var cache = {};

function decodeParam(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}

function matchPath(route, pathname, parentParams) {
  var path = route.path,
      routes = route.routes,
      _route$exact = route.exact,
      end = _route$exact === void 0 ? true : _route$exact,
      _route$strict = route.strict,
      strict = _route$strict === void 0 ? false : _route$strict,
      _route$sensitive = route.sensitive,
      sensitive = _route$sensitive === void 0 ? false : _route$sensitive; // If not has path or has routes that should do not exact match

  if (path == null || routes) {
    end = false;
  } // Default path is empty


  path = path || '';
  var regexpCacheKey = path + "|" + end + "|" + strict + "|" + sensitive;
  var keysCacheKey = regexpCacheKey + '|';
  var regexp = cache[regexpCacheKey];
  var keys = cache[keysCacheKey] || [];

  if (!regexp) {
    regexp = (0, _pathToRegexp.default)(path, keys, {
      end: end,
      strict: strict,
      sensitive: sensitive
    });
    cache[regexpCacheKey] = regexp;
    cache[keysCacheKey] = keys;
  }

  var result = regexp.exec(pathname);

  if (!result) {
    return null;
  }

  var url = result[0];

  var params = _extends({}, parentParams, {
    history: router.history,
    location: router.history.location
  });

  for (var i = 1; i < result.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var value = result[i];

    if (value !== undefined || !Object.prototype.hasOwnProperty.call(params, prop)) {
      if (key.repeat) {
        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
      } else {
        params[prop] = value ? decodeParam(value) : value;
      }
    }
  }

  return {
    path: !end && url.charAt(url.length - 1) === '/' ? url.substr(1) : url,
    params: params
  };
}

function matchRoute(route, baseUrl, pathname, parentParams) {
  var matched;
  var childMatches;
  var childIndex = 0;
  return {
    next: function next() {
      if (!matched) {
        matched = matchPath(route, pathname, parentParams);

        if (matched) {
          return {
            done: false,
            $: {
              route: route,
              baseUrl: baseUrl,
              path: matched.path,
              params: matched.params
            }
          };
        }
      }

      if (matched && route.routes) {
        while (childIndex < route.routes.length) {
          if (!childMatches) {
            var childRoute = route.routes[childIndex];
            childRoute.parent = route;
            childMatches = matchRoute(childRoute, baseUrl + matched.path, pathname.substr(matched.path.length), matched.params);
          }

          var childMatch = childMatches.next();

          if (!childMatch.done) {
            return {
              done: false,
              $: childMatch.$
            };
          }

          childMatches = null;
          childIndex++;
        }
      }

      return {
        done: true
      };
    }
  };
}

var _initialized = false;
var _routerConfig = null;
var router = {
  history: null,
  handles: [],
  errorHandler: function errorHandler() {},
  addHandle: function addHandle(handle) {
    return router.handles.push(handle);
  },
  removeHandle: function removeHandle(handleId) {
    router.handles[handleId - 1] = null;
  },
  triggerHandles: function triggerHandles(component) {
    router.handles.map(function (handle) {
      handle && handle(component);
    });
  },
  match: function match(fullpath) {
    if (fullpath == null) return;
    router.fullpath = fullpath;
    var parent = router.root;
    var matched = matchRoute(parent, parent.path, fullpath);

    function next(parent) {
      var current = matched.next();

      if (current.done) {
        var error = new Error("No match for " + fullpath);
        return router.errorHandler(error, router.history.location);
      }

      var component = current.$.route.component;

      if (typeof component === 'function') {
        component = component(current.$.params, router.history.location);
      }

      if (component instanceof Promise) {
        // Lazy loading component by import('./Foo')
        return component.then(function (component) {
          // Check current fullpath avoid router has changed before lazy loading complete
          if (fullpath === router.fullpath) {
            router.triggerHandles(component);
          }
        });
      } else if (component != null) {
        router.triggerHandles(component);
        return component;
      } else {
        return next(parent);
      }
    }

    return next(parent);
  }
};

function matchLocation(_ref) {
  var pathname = _ref.pathname;
  router.match(pathname);
}

function getInitialComponent(routerConfig) {
  var InitialComponent = [];

  if (_routerConfig === null) {
    if (typeof routerConfig === 'function') {
      routerConfig = routerConfig();
    }

    if (process.env.NODE_ENV !== 'production') {
      if (!routerConfig) {
        throw new Error('Error: useRouter should have routerConfig, see: https://www.npmjs.com/package/rax-use-router.');
      }

      if (!routerConfig.history || !routerConfig.routes) {
        throw new Error('Error: routerConfig should contain history and routes, see: https://www.npmjs.com/package/rax-use-router.');
      }
    }

    _routerConfig = routerConfig;
  }

  if (_routerConfig.InitialComponent) {
    InitialComponent = _routerConfig.InitialComponent;
  }

  router.history = _routerConfig.history;
  return InitialComponent;
}

function useRouter(routerConfig) {
  var _useState = (0, _rax.useState)(getInitialComponent(routerConfig)),
      component = _useState[0],
      setComponent = _useState[1];

  (0, _rax.useLayoutEffect)(function () {
    if (_initialized) throw new Error('Error: useRouter can only be called once.');
    _initialized = true;
    var history = _routerConfig.history;
    var routes = _routerConfig.routes;
    router.root = Array.isArray(routes) ? {
      routes: routes
    } : routes;
    var handleId = router.addHandle(function (component) {
      setComponent(component);
    }); // Init path match

    if (!_routerConfig.InitialComponent) {
      matchLocation(history.location);
    }

    var unlisten = history.listen(function (location, action) {
      matchLocation(location);
    });
    return function () {
      router.removeHandle(handleId);
      unlisten();
    };
  }, []);
  return {
    component: component
  };
}

function withRouter(Component) {
  function Wrapper(props) {
    var history = router.history;
    return (0, _rax.createElement)(Component, _extends({}, props, {
      history: history,
      location: history.location
    }));
  }

  ;
  Wrapper.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  Wrapper.WrappedComponent = Component;
  return Wrapper;
}