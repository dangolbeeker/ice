"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withModel = exports.createStore = void 0;
var react_1 = __importDefault(require("react"));
var redux_thunk_1 = __importDefault(require("redux-thunk"));
var icestore_1 = __importDefault(require("./icestore"));
var mergeConfig_1 = __importDefault(require("./utils/mergeConfig"));
var provider_1 = __importDefault(require("./plugins/provider"));
var reduxHooks_1 = __importDefault(require("./plugins/reduxHooks"));
var modelApis_1 = __importDefault(require("./plugins/modelApis"));
var immer_1 = __importDefault(require("./plugins/immer"));
var loading_1 = __importDefault(require("./plugins/loading"));
var error_1 = __importDefault(require("./plugins/error"));
var converter_1 = require("./utils/converter");
var appendReducers_1 = __importDefault(require("./utils/appendReducers"));
// incrementer used to provide a store name if none exists
var count = 0;
/**
 * createOriginStore
 *
 * generates a Icestore with a set configuration
 * @param config
 */
var init = function (initConfig) {
    if (initConfig === void 0) { initConfig = {}; }
    var name = initConfig.name || count.toString();
    count += 1;
    var config = mergeConfig_1.default(__assign(__assign({}, initConfig), { name: name }));
    return new icestore_1.default(config).init();
};
/**
 * createStore
 *
 * generates a preset Icestore
 * @param models
 * @param initConfig
 */
exports.createStore = function (models, initConfig) {
    var _a = initConfig || {}, disableImmer = _a.disableImmer, disableLoading = _a.disableLoading, disableError = _a.disableError, _b = _a.plugins, plugins = _b === void 0 ? [] : _b, _c = _a.redux, redux = _c === void 0 ? {} : _c;
    var middlewares = redux.middlewares || [];
    var context = react_1.default.createContext(null);
    // defaults middlewares
    middlewares.push(redux_thunk_1.default);
    // defaults plugins
    plugins.push(provider_1.default({ context: context }));
    plugins.push(reduxHooks_1.default({ context: context }));
    plugins.push(modelApis_1.default());
    // https://github.com/ice-lab/icestore/issues/94
    // TODO: fix error & loading plugin immer problem
    var immerBlacklist = [];
    if (!disableLoading) {
        plugins.push(loading_1.default());
        immerBlacklist.push('loading');
    }
    if (!disableError) {
        plugins.push(error_1.default());
        immerBlacklist.push('error');
    }
    if (!disableImmer) {
        plugins.push(immer_1.default({ blacklist: immerBlacklist }));
    }
    // compatibility handling
    var wrappedModels = appendReducers_1.default(converter_1.convertEffects(converter_1.convertActions(models)));
    var store = init({
        models: wrappedModels,
        plugins: plugins,
        redux: __assign(__assign({}, redux), { middlewares: middlewares }),
    });
    return store;
};
exports.withModel = function (model, mapModelToProps, initConfig) {
    var _a;
    var modelName = 'model';
    mapModelToProps = (mapModelToProps || (function (modelApis) {
        var _a;
        return (_a = {}, _a[modelName] = modelApis, _a);
    }));
    var store = exports.createStore((_a = {}, _a[modelName] = model, _a), initConfig);
    var Provider = store.Provider, getModelAPIs = store.getModelAPIs;
    var modelApis = getModelAPIs(modelName);
    var withProps = mapModelToProps(modelApis);
    return function (Component) {
        return function (props) {
            return (react_1.default.createElement(Provider, null,
                react_1.default.createElement(Component, __assign({}, withProps, props))));
        };
    };
};
exports.default = exports.createStore;
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map