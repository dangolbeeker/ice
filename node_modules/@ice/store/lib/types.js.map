{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import * as Redux from 'redux';\nimport React from 'react';\n\nexport type Optionalize<T extends K, K> = Omit<T, keyof K>;\n\ntype PropType<Obj, Prop extends keyof Obj> = Obj[Prop];\n\ninterface EffectState {\n  isLoading: boolean;\n  error: Error;\n}\n\ntype EffectsState<Effects> = {\n  [K in keyof Effects]: EffectState;\n}\n\ntype EffectsLoading<Effects> = {\n  [K in keyof Effects]: boolean;\n}\n\ntype EffectsError<Effects> = {\n  [K in keyof Effects]: {\n    error: Error;\n    value: number;\n  };\n}\n\nexport type ExtractIcestoreStateFromModels<M extends Models> = {\n  [modelKey in keyof M]: M[modelKey]['state']\n}\n\nexport type IcestoreRootState<M extends Models> = ExtractIcestoreStateFromModels<\nM\n>\n\ntype ExtractIModelDispatcherAsyncFromEffect<\n  E\n> = E extends () => Promise<infer R>\n  ? IcestoreDispatcherAsync<void, void, R>\n  : E extends (payload: infer P) => Promise<infer R>\n    ? IcestoreDispatcherAsync<P, void, R>\n    : E extends (payload: infer P, rootState: any) => Promise<infer R>\n      ? IcestoreDispatcherAsync<P, void, R>\n      : E extends (payload: infer P, rootState: any, meta: infer M) => Promise<infer R>\n        ? IcestoreDispatcherAsync<P, M, R>\n        : IcestoreDispatcherAsync<any, any, any>\n\ntype ExtractIModelDispatchersFromEffectsObject<\n  effects extends ModelEffects<any>\n> = {\n  [effectKey in keyof effects]: ExtractIModelDispatcherAsyncFromEffect<\n  effects[effectKey]\n  >\n}\n\nexport type ExtractIModelDispatchersFromEffects<\n  effects extends ModelConfig['effects']\n> = effects extends ((...args: any[]) => infer R)\n  ? R extends ModelEffects<any>\n    ? ExtractIModelDispatchersFromEffectsObject<R>\n    : {}\n  : effects extends ModelEffects<any>\n    ? ExtractIModelDispatchersFromEffectsObject<effects>\n    : effects extends ConfigEffects<any> ?\n      OldModelEffects<any> : {};\n\ntype ExtractIModelDispatcherFromReducer<R> = R extends () => any\n  ? IcestoreDispatcher<void, void>\n  : R extends (state: infer S) => infer S\n    ? IcestoreDispatcher<void, void>\n    : R extends (state: infer S, payload: infer P) => (infer S | void)\n      ? IcestoreDispatcher<P, void>\n      : R extends (state: infer S, payload: infer P, meta: infer M) => (infer S | void)\n        ? IcestoreDispatcher<P, M>\n        : IcestoreDispatcher<any, any>\n\ninterface DefaultIModelDispatchersFromReducersObject {\n  setState: IcestoreDispatcher<any, any>;\n}\n\ntype ExtractIModelDispatchersFromReducersObject<\n  reducers extends ModelReducers<any>\n> = {\n  [reducerKey in keyof reducers]: ExtractIModelDispatcherFromReducer<\n  reducers[reducerKey]\n  >;\n} & DefaultIModelDispatchersFromReducersObject;\n\nexport type ExtractIModelDispatchersFromReducers<\n  reducers extends ModelConfig['reducers']\n> = ExtractIModelDispatchersFromReducersObject<reducers & {}>\n\nexport type ExtractIModelStateFromModelConfig<M extends ModelConfig> = PropType<M, 'state'>;\n\nexport type ExtractIModelEffectsFromModelConfig<M extends ModelConfig> = PropType<M, 'effects'>;\n\nexport type ExtractIModelReducersFromModelConfig<M extends ModelConfig> = PropType<M, 'reducers'>;\n\nexport type ExtractIModelFromModelConfig<M extends ModelConfig> = [\n  ExtractIModelStateFromModelConfig<M>,\n  ExtractIModelDispatchersFromModelConfig<M>,\n];\n\nexport type ExtractIModelEffectsErrorFromModelConfig<M extends ModelConfig> = EffectsError<\nExtractIModelDispatchersFromEffects<ExtractIModelEffectsFromModelConfig<M>>\n>;\n\nexport type ExtractIModelEffectsLoadingFromModelConfig<M extends ModelConfig> = EffectsLoading<\nExtractIModelDispatchersFromEffects<ExtractIModelEffectsFromModelConfig<M>>\n>;\n\nexport type ExtractIModelEffectsStateFromModelConfig<M extends ModelConfig> = EffectsState<\nExtractIModelDispatchersFromEffects<ExtractIModelEffectsFromModelConfig<M>>\n>;\n\nexport type ExtractIModelDispatchersFromModelConfig<\n  M extends ModelConfig\n> = ExtractIModelDispatchersFromReducers<ExtractIModelReducersFromModelConfig<M>> &\nExtractIModelDispatchersFromEffects<ExtractIModelEffectsFromModelConfig<M>>\n\nexport type ExtractIcestoreDispatchersFromModels<M extends Models> = {\n  [modelKey in keyof M]: ExtractIModelDispatchersFromModelConfig<M[modelKey]>\n}\n\ntype IcestoreDispatcher<P = void, M = void> = ([P] extends [void]\n  ? ((...args: any[]) => Action<any, any>)\n  : [M] extends [void]\n    ? ((payload: P) => Action<P, void>)\n    : (payload: P, meta: M) => Action<P, M>) &\n((action: Action<P, M>) => Redux.Dispatch<Action<P, M>>) &\n((action: Action<P, void>) => Redux.Dispatch<Action<P, void>>)\n\ntype IcestoreDispatcherAsync<P = void, M = void, R = void> = ([P] extends [void]\n  ? ((...args: any[]) => Promise<R>)\n  : [M] extends [void]\n    ? ((payload: P) => Promise<R>)\n    : (payload: P, meta: M) => Promise<R>) &\n((action: Action<P, M>) => Promise<R>) &\n((action: Action<P, void>) => Promise<R>)\n\nexport type IcestoreDispatch<M extends Models | void = void> = (M extends Models\n  ? ExtractIcestoreDispatchersFromModels<M>\n  : {\n    [key: string]: {\n      [key: string]: IcestoreDispatcher | IcestoreDispatcherAsync;\n    };\n\t  }) &\n(IcestoreDispatcher | IcestoreDispatcherAsync) &\n(Redux.Dispatch<any>) // for library compatability\n\nexport interface Icestore<\n  M extends Models = Models,\n  A extends Action = Action\n> extends Redux.Store<IcestoreRootState<M>, A> {\n  name: string;\n  replaceReducer(nextReducer: Redux.Reducer<IcestoreRootState<M>, A>): void;\n  dispatch: IcestoreDispatch<M>;\n  getState(): IcestoreRootState<M>;\n  model(model: Model): void;\n  subscribe(listener: () => void): Redux.Unsubscribe;\n}\n\ninterface UseModelEffectsError<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelEffectsErrorFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface MapModelEffectsErrorToProps<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(effectsLoading: ExtractIModelEffectsErrorFromModelConfig<Key extends undefined ? M[K] : M[Key]>): Record<string, any>;\n}\n\ninterface WithModelEffectsError<M extends Models = Models, F extends MapModelEffectsErrorToProps<M> = MapModelEffectsErrorToProps<M>> {\n  <K extends keyof M>(name: K, mapModelEffectsErrorToProps?: F):\n  <R extends ReturnType<F>, P extends R>(Component: React.ComponentType<P>) =>\n  (props: Optionalize<P, R>) => React.ReactElement;\n}\n\ninterface ModelEffectsErrorAPI<M extends Models = Models> {\n  useModelEffectsError: UseModelEffectsError<M>;\n  withModelEffectsError: WithModelEffectsError<M>;\n}\n\ninterface UseModelEffectsLoading<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelEffectsLoadingFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface MapModelEffectsLoadingToProps<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(effectsLoading: ExtractIModelEffectsLoadingFromModelConfig<Key extends undefined ? M[K] : M[Key]>): Record<string, any>;\n}\n\ninterface WithModelEffectsLoading<M extends Models = Models, F extends MapModelEffectsLoadingToProps<M> = MapModelEffectsLoadingToProps<M>> {\n  <K extends keyof M>(name: K, mapModelEffectsLoadingToProps?: F):\n  <R extends ReturnType<F>, P extends R>(Component: React.ComponentType<P>) =>\n  (props: Optionalize<P, R>) => React.ReactElement;\n}\n\ninterface ModelEffectsLoadingAPI<M extends Models = Models> {\n  useModelEffectsLoading: UseModelEffectsLoading<M>;\n  withModelEffectsLoading: WithModelEffectsLoading<M>;\n}\n\ninterface UseModelEffectsState<M extends Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelEffectsStateFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface MapModelEffectsStateToProps<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(effectsState: ExtractIModelEffectsStateFromModelConfig<Key extends undefined ? M[K] : M[Key]>): Record<string, any>;\n}\n\ninterface WithModelEffectsState<M extends Models = Models, F extends MapModelEffectsStateToProps<M> = MapModelEffectsStateToProps<M>> {\n  <K extends keyof M>(name: K, mapModelEffectsStateToProps?: F):\n  <R extends ReturnType<F>, P extends R>(Component: React.ComponentType<P>) =>\n  (props: Optionalize<P, R>) => React.ReactElement;\n}\n\ninterface ModelEffectsStateAPI<M extends Models = Models> {\n  useModelEffectsState: UseModelEffectsState<M>;\n\n  /**\n   * @deprecated use `useModelEffectsState` instead\n   */\n  useModelActionsState: UseModelEffectsState<M>;\n  withModelEffectsState: WithModelEffectsState<M>;\n\n  /**\n   * @deprecated use `withModelEffectsState` instead\n   */\n  withModelActionsState: WithModelEffectsState<M>;\n}\n\ninterface UseModelState<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelStateFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface ModelStateAPI<M extends Models = Models> {\n  useModelState: UseModelState<M>;\n  getModelState: UseModelState<M>;\n}\n\ninterface UseModelDispatchers<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelDispatchersFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface MapModelDispatchersToProps<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(dispatchers: ExtractIModelDispatchersFromModelConfig<Key extends undefined ? M[K] : M[Key]>): Record<string, any>;\n}\n\ninterface WithModelDispatchers<M extends Models = Models, F extends MapModelDispatchersToProps<M> = MapModelDispatchersToProps<M>> {\n  <K extends keyof M>(name: K, mapModelDispatchersToProps?: F):\n  <R extends ReturnType<F>, P extends R>(Component: React.ComponentType<P>) =>\n  (props: Optionalize<P, R>) => React.ReactElement;\n}\n\ninterface ModelDispathersAPI<M extends Models = Models> {\n  useModelDispatchers: UseModelDispatchers<M>;\n  /**\n   * @deprecated use `useModelDispatchers` instead.\n   */\n  useModelActions: UseModelDispatchers<M>;\n  getModelDispatchers: UseModelDispatchers<M>;\n  withModelDispatchers: WithModelDispatchers<M>;\n  /**\n   * @deprecated use `withModelDispatchers` instead.\n   */\n  withModelActions: WithModelDispatchers<M>;\n}\n\ninterface UseModel<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): ExtractIModelFromModelConfig<Key extends undefined ? M[K] : M[Key]>;\n}\n\ninterface MapModelToProps<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(model: ExtractIModelFromModelConfig<Key extends undefined ? M[K] : M[Key]>): Record<string, any>;\n}\n\ninterface WithModel<M extends Models = Models, F extends MapModelToProps<M> = MapModelToProps<M>> {\n  <K extends keyof M>(name: K, mapModelToProps?: F):\n  <R extends ReturnType<F>, P extends R>(Component: React.ComponentType<P>) =>\n  (props: Optionalize<P, R>) => React.ReactElement;\n}\n\ninterface ModelValueAPI<M extends Models = Models> {\n  useModel: UseModel<M>;\n  getModel: UseModel<M>;\n  withModel: WithModel<M>;\n}\n\ninterface GetModelAPIsValue<M extends Models = Models, K extends keyof M = keyof M> {\n  // ModelValueAPI\n  useValue: () => ReturnType<UseModel<M, K>>;\n  getValue: () => ReturnType<UseModel<M, K>>;\n  withValue: <F extends MapModelToProps<M, K>>(f?: F) => ReturnType<WithModel<M, F>>;\n  // ModelStateAPI\n  useModelState: () => ReturnType<UseModelState<M, K>>;\n  getModelState: () => ReturnType<UseModelState<M, K>>;\n  // ModelDispathersAPI\n  useDispatchers: () => ReturnType<UseModelDispatchers<M, K>>;\n  getDispatchers: () => ReturnType<UseModelDispatchers<M, K>>;\n  withDispatchers: <F extends MapModelDispatchersToProps<M, K>>(f?: F) => ReturnType<WithModelDispatchers<M, F>>;\n  // ModelEffectsLoadingAPI\n  useEffectsLoading: () => ReturnType<UseModelEffectsLoading<M, K>>;\n  withEffectsLoading: <F extends MapModelEffectsLoadingToProps<M, K>>(f?: F) => ReturnType<WithModelEffectsLoading<M, F>>;\n  // ModelEffectsErrorAPI\n  useEffectsError: () => ReturnType<UseModelEffectsError<M, K>>;\n  withEffectsError: <F extends MapModelEffectsErrorToProps<M, K>>(f?: F) => ReturnType<WithModelEffectsError<M, F>>;\n  // ModelEffectsStateAPI\n  useModelEffectsState: () => ReturnType<UseModelEffectsState<M>>;\n  withModelEffectsState: <F extends MapModelEffectsStateToProps<M, K>>(f?: F) => ReturnType<WithModelEffectsState<M, F>>;\n}\n\ninterface GetModelAPIs<M extends Models = Models, Key extends keyof M = undefined> {\n  <K extends keyof M>(name: K): GetModelAPIsValue<M, Key extends undefined ? K : Key>;\n}\n\ntype ModelAPI<M extends Models = Models> =\n  {\n    getModelAPIs: GetModelAPIs<M>;\n  } &\n  ModelValueAPI<M> &\n  ModelStateAPI<M> &\n  ModelDispathersAPI<M> &\n  ModelEffectsLoadingAPI<M> &\n  ModelEffectsErrorAPI<M> &\n  ModelEffectsStateAPI<M>;\n\ninterface ProviderProps {\n  children: any;\n  initialStates?: any;\n}\n\ninterface ProviderPluginAPI {\n  Provider: (props: ProviderProps) => JSX.Element;\n  context: React.Context<{ store: PresetIcestore }>;\n}\n\nexport type ExtractIModelAPIsFromModelConfig<M extends ModelConfig> = ReturnType<GetModelAPIs<{ model: M }, 'model'>>;\n\nexport type PresetIcestore<\n  M extends Models = Models,\n  A extends Action = Action,\n> = Icestore<M, A> &\nModelAPI<M> &\nProviderPluginAPI;\n\nexport interface Action<P = any, M = any> {\n  type: string;\n  payload?: P;\n  meta?: M;\n}\n\nexport interface ModelReducers<S = any> {\n  [key: string]: (state: S, payload: any, meta?: any) => S;\n}\n\nexport interface ModelEffects<S> {\n  [key: string]: (\n    this: { [key: string]: (payload?: any, meta?: any) => Action<any, any> },\n    payload: any,\n    rootState?: S,\n    meta?: any\n  ) => void;\n}\n\nexport interface Models {\n  [key: string]: ModelConfig;\n}\n\nexport type ModelHook = (model: Model) => void\n\nexport type Validation = [boolean | undefined, string]\n\nexport interface Model<S = any, SS = S> extends ModelConfig<S, SS> {\n  name: string;\n  reducers: ModelReducers<S>;\n}\n\nexport interface ModelConfig<S = any, SS = S> {\n  name?: string;\n  state: S;\n  baseReducer?: (state: SS, action: Action) => SS;\n  reducers?: ModelReducers<S> | ConfigReducers;\n  effects?:\n  | ModelEffects<any>\n  | ((dispatch: IcestoreDispatch) => ModelEffects<any>)\n  | ConfigEffects;\n\n  /**\n   * @deprecated use `effects` instead.\n   */\n  actions?: ConfigActions<S>;\n}\n\nexport interface PluginFactory extends Plugin {\n  create(plugin: Plugin): Plugin;\n}\n\nexport interface Plugin<M extends Models = Models, A extends Action = Action> {\n  config?: InitConfig<M>;\n  onInit?: () => void;\n  onStoreCreated?: (store: Icestore<M, A>) => void;\n  onModel?: ModelHook;\n  middleware?: Middleware;\n\n  // exposed\n  exposed?: {\n    [key: string]: any;\n  };\n  validate?(validations: Validation[]): void;\n  storeDispatch?(action: Action, state: any): Redux.Dispatch<any> | undefined;\n  storeGetState?(): any;\n  dispatch?: IcestoreDispatch<M>;\n  effects?: Record<string, any>;\n  createDispatcher?(modelName: string, reducerName: string): void;\n}\n\nexport interface RootReducers {\n  [type: string]: Redux.Reducer<any, Action>;\n}\n\nexport interface DevtoolOptions {\n  disabled?: boolean;\n  [key: string]: any;\n}\n\nexport interface InitConfigRedux<S = any> {\n  initialStates?: S;\n  reducers?: ModelReducers;\n  enhancers?: Redux.StoreEnhancer<any>[];\n  middlewares?: Middleware[];\n  rootReducers?: RootReducers;\n  combineReducers?: (\n    reducers: Redux.ReducersMapObject\n  ) => Redux.Reducer<any, Action>;\n  createStore?: Redux.StoreCreator;\n  devtoolOptions?: DevtoolOptions;\n}\n\nexport interface InitConfig<M extends Models = Models> {\n  name?: string;\n  models?: M;\n  plugins?: Plugin[];\n  redux?: InitConfigRedux;\n}\n\nexport interface PrsetConfig {\n  disableImmer?: boolean;\n  disableLoading?: boolean;\n  disableError?: boolean;\n}\n\nexport type CreateStoreConfig<M extends Models = Models> = InitConfig<M> & PrsetConfig;\n\nexport interface Config<M extends Models = Models> extends InitConfig {\n  name: string;\n  models: M;\n  plugins: Plugin[];\n  redux: ConfigRedux;\n}\n\nexport interface Middleware<\n  DispatchExt = {},\n  S = any,\n  D extends Redux.Dispatch = Redux.Dispatch\n> {\n  (api: Redux.MiddlewareAPI<D, S>): (\n    next: Redux.Dispatch<Action>\n  ) => (action: any, state?: any) => any;\n}\n\nexport interface ConfigRedux {\n  initialStates?: any;\n  reducers: ModelReducers;\n  enhancers: Redux.StoreEnhancer<any>[];\n  middlewares: Middleware[];\n  rootReducers?: RootReducers;\n  combineReducers?: (\n    reducers: Redux.ReducersMapObject\n  ) => Redux.Reducer<any, Action>;\n  createStore?: Redux.StoreCreator;\n  devtoolOptions?: DevtoolOptions;\n}\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: any;\n  }\n}\n\n/**\n * @deprecated\n */\nexport type ConfigAction<S = any> = (prevState: S, payload?: any, actions?: any, globalActions?: any) => S | Promise<S>;\n/**\n * @deprecated\n */\nexport type ConfigEffect<S = any> = (state: S, payload?: any, actions?: any, globalActions?: any) => void | Promise<void>;\n/**\n * @deprecated\n */\nexport type ConfigReducer<S = any> = (state: S, payload?: any,) => S;\n/**\n * @deprecated use `ModelEffects` instead\n */\nexport interface ConfigEffects<S = any> {\n  [name: string]: ConfigEffect<S>;\n}\n/**\n * @deprecated\n */\nexport interface ConfigReducers<S = any> {\n  [name: string]: ConfigReducer<S>;\n}\n/**\n * @deprecated\n */\nexport interface ConfigActions<S = any> {\n  [name: string]: ConfigAction<S>;\n}\n/**\n * @deprecated\n */\nexport type Actions<A extends ConfigEffects> = {\n  [K in keyof A]: (payload?: Parameters<A[K]>[1]) => void;\n}\n/**\n * @deprecated use `ExtractIModelStateFromModelConfig` instead\n */\nexport type ConfigPropTypeState<C extends ModelConfig> = PropType<C, 'state'>;\n/**\n * @deprecated\n */\nexport type ConfigPropTypeActions<C extends ModelConfig> = PropType<C, 'actions'>;\n/**\n * @deprecated use `ExtractIModelEffectsFromModelConfig` instead\n */\nexport type ConfigPropTypeEffects<C extends ModelConfig> = PropType<C, 'effects'>;\n/**\n * @deprecated use `ExtractIModelReducersFromModelConfig` instead\n */\nexport type ConfigPropTypeReducers<C extends ModelConfig> = PropType<C, 'reducers'>;\n/**\n * @deprecated\n */\nexport type ConfigMergedEffects<C extends ModelConfig> = ConfigPropTypeActions<C> & ConfigPropTypeEffects<C>;\n/**\n * @deprecated use `ExtractIModelDispatchersFromEffects` instead\n */\nexport type OldModelEffects<C extends ModelConfig> = Actions<ConfigMergedEffects<C>>;\n/**\n * @deprecated use `ExtractIModelDispatchersFromModelConfig` instead\n */\nexport type ModelActions<C extends ModelConfig> = Actions<ConfigPropTypeReducers<C> & ConfigPropTypeEffects<C>>;\n/**\n * @deprecated use `ExtractIModelEffectsStateFromModelConfig` instead\n */\nexport type ModelEffectsState<C extends ModelConfig> = ExtractIModelEffectsStateFromModelConfig<C>;\n/**\n * @deprecated\n */\nexport type ModelValue<C extends ModelConfig> = [ ConfigPropTypeState<C>, ModelActions<C>, ModelEffectsState<C> ];\n/**\n * @deprecated use `ExtractIModelFromModelConfig` instead\n */\nexport type UseModelValue<C extends ModelConfig> = [ ConfigPropTypeState<C>, ModelActions<C> ];\n"]}