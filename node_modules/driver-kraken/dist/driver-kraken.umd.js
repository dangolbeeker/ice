(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.DriverKraken = {}));
}(this, (function (exports) {
	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var lib$1 = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports.isQuickApp = exports.isWeChatMiniProgram = exports.isByteDanceMicroApp = exports.isMiniApp = exports.isKraken = exports.isWeex = exports.isNode = exports.isWeb = void 0;

	  function isUndef(type) {
	    return type === 'undefined';
	  }

	  var isWeb = !isUndef(typeof window) && 'onload' in window;
	  exports.isWeb = isWeb;
	  var isNode = !isUndef(typeof process) && !!(process.versions && process.versions.node);
	  exports.isNode = isNode;
	  var isWeex = !isUndef(typeof WXEnvironment) && WXEnvironment.platform !== 'Web';
	  exports.isWeex = isWeex;
	  var isKraken = !isUndef(typeof __kraken__);
	  exports.isKraken = isKraken;
	  var isMiniApp = !isUndef(typeof my) && my !== null && !isUndef(typeof my.alert);
	  exports.isMiniApp = isMiniApp;
	  var isByteDanceMicroApp = !isUndef(typeof tt) && tt !== null && !isUndef(typeof tt) && !isUndef(tt.showToast); // In wechat mini program, wx.login is a function
	  // In wechat mini propgram webview, there is no wx.login, but exist wx.miniProgram
	  // In bytedance maicro app, there is wx variable.

	  exports.isByteDanceMicroApp = isByteDanceMicroApp;
	  var isWeChatMiniProgram = !isByteDanceMicroApp && !isUndef(typeof wx) && wx !== null && (!isUndef(typeof wx.login) || !isUndef(typeof wx.miniProgram));
	  exports.isWeChatMiniProgram = isWeChatMiniProgram;
	  var isQuickApp = !isUndef(typeof commonjsGlobal) && commonjsGlobal !== null && !isUndef(typeof commonjsGlobal.callNative) && !isWeex;
	  exports.isQuickApp = isQuickApp;
	});

	var lib = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports.isRpx = isRpx;
	  exports.calcRpx = calcRpx;
	  exports.getRpx = getRpx;
	  exports.setRpx = setRpx;
	  exports.getViewportWidth = getViewportWidth;
	  exports.setViewportWidth = setViewportWidth;
	  exports.setDecimalPixelTransformer = setDecimalPixelTransformer;
	  exports.setUnitPrecision = setUnitPrecision;
	  exports.cached = cached;
	  exports.setTargetPlatform = setTargetPlatform;
	  exports.convertUnit = void 0;
	  var RPX_REG = /"[^"]+"|'[^']+'|url\([^\)]+\)|(\d*\.?\d+)rpx/g;

	  var __rpx_coefficient__;

	  var __viewport_width__; // convertUnit method targetPlatform


	  var targetPlatform = lib$1.isWeb ? 'web' : lib$1.isWeex ? 'weex' : ''; // Init toFixed method

	  var unitPrecision = 4;

	  var toFixed = function toFixed(number, precision) {
	    var multiplier = Math.pow(10, precision + 1);
	    var wholeNumber = Math.floor(number * multiplier);
	    return Math.round(wholeNumber / 10) * 10 / multiplier;
	  }; // Dedault decimal px transformer.


	  var decimalPixelTransformer = function decimalPixelTransformer(rpx, $1) {
	    return $1 ? parseFloat(rpx) * getRpx() + 'px' : rpx;
	  }; // Default decimal vw transformer.


	  var decimalVWTransformer = function decimalVWTransformer(rpx, $1) {
	    return $1 ? toFixed(parseFloat(rpx) / (getViewportWidth() / 100), unitPrecision) + 'vw' : rpx;
	  }; // Default 1 rpx to 1 px


	  if (getRpx() === undefined) {
	    setRpx(1);
	  } // Viewport width, default to 750.


	  if (getViewportWidth() === undefined) {
	    setViewportWidth(750);
	  }
	  /**
	   * Is string contains rpx
	   * note: rpx is an alias to rpx
	   * @param {String} str
	   * @returns {Boolean}
	   */


	  function isRpx(str) {
	    return typeof str === 'string' && RPX_REG.test(str);
	  }
	  /**
	   * Calculate rpx
	   * @param {String} str
	   * @returns {String}
	   */


	  function calcRpx(str) {
	    if (targetPlatform === 'web') {
	      // In Web convert rpx to 'vw', same as driver-dom and driver-universal
	      // '375rpx' => '50vw'
	      return str.replace(RPX_REG, decimalVWTransformer);
	    } else if (targetPlatform === 'weex') {
	      // In Weex convert rpx to 'px'
	      // '375rpx' => 375 * px
	      return str.replace(RPX_REG, decimalPixelTransformer);
	    } else {
	      // Other platform return original value, like Mini-App and WX Mini-Program ...
	      // '375rpx' => '375rpx'
	      return str;
	    }
	  }

	  function getRpx() {
	    return __rpx_coefficient__;
	  }

	  function setRpx(rpx) {
	    __rpx_coefficient__ = rpx;
	  }

	  function getViewportWidth() {
	    return __viewport_width__;
	  }

	  function setViewportWidth(viewport) {
	    __viewport_width__ = viewport;
	  }
	  /**
	   * Set a function to transform unit of pixel,
	   * default to passthrough.
	   * @param {Function} transformer function
	   */


	  function setDecimalPixelTransformer(transformer) {
	    decimalPixelTransformer = transformer;
	  }
	  /**
	   * Set unit precision.
	   * @param n {Number} Unit precision, default to 4.
	   */


	  function setUnitPrecision(n) {
	    unitPrecision = n;
	  }
	  /**
	   * Create a cached version of a pure function.
	   * Use the first params as cache key.
	   */


	  function cached(fn) {
	    var cache = new Map();
	    return function cachedFn() {
	      var key = arguments.length <= 0 ? undefined : arguments[0];
	      if (!cache.has(key)) cache.set(key, fn.apply(void 0, arguments));
	      return cache.get(key);
	    };
	  }

	  function setTargetPlatform(platform) {
	    targetPlatform = platform;
	  }
	  /**
	   * Convert rpx.
	   * @param value
	   * @param prop
	   * @param platform
	   * @return {String} Transformed value.
	   */


	  var convertUnit = cached(function (value, prop, platform) {
	    if (platform) {
	      setTargetPlatform(platform);
	    }

	    return isRpx(value) ? calcRpx(value) : value;
	  });
	  exports.convertUnit = convertUnit;
	});

	/**
	 * Driver for Kraken
	 **/
	var NON_DIMENSIONAL_REG = /opa|ntw|ne[ch]|ex(?:s|g|n|p|$)|^ord|zoo|grid|orp|ows|mnc|^columns$|bs|erim|onit/i;
	var EVENT_PREFIX_REG = /^on[A-Z]/;
	var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
	var CLASS_NAME = 'className';
	var CLASS = 'class';
	var STYLE = 'style';
	var CHILDREN = 'children';
	var TEXT_CONTENT_ATTR = 'textContent';
	var CREATE_ELEMENT = 'createElement';
	var CREATE_COMMENT = 'createComment';
	var CREATE_TEXT_NODE = 'createTextNode';
	var SET_ATTRIBUTE = 'setAttribute';
	var REMOVE_ATTRIBUTE = 'removeAttribute';
	var EMPTY = '';
	var isEventProp = lib.cached(function (prop) {
	  return EVENT_PREFIX_REG.test(prop);
	});
	function createBody() {
	  return document.body;
	}
	function createEmpty(component) {
	  return document[CREATE_COMMENT](EMPTY);
	}
	function createText(text, component) {
	  return document[CREATE_TEXT_NODE](text);
	}
	function updateText(node, text) {
	  node[TEXT_CONTENT_ATTR] = text;
	}
	function createElement(type, props, component, __shouldConvertUnitlessToRpx) {
	  var node = document[CREATE_ELEMENT](type);

	  for (var prop in props) {
	    var value = props[prop];
	    if (prop === CHILDREN) continue;

	    if (value != null) {
	      if (prop === STYLE) {
	        setStyle(node, value, __shouldConvertUnitlessToRpx);
	      } else if (isEventProp(prop)) {
	        addEventListener(node, prop.slice(2).toLowerCase(), value);
	      } else {
	        setAttribute(node, prop, value);
	      }
	    }
	  }

	  return node;
	}
	function appendChild(node, parent) {
	  return parent.appendChild(node);
	}
	function removeChild(node, parent) {
	  parent = parent || node.parentNode; // Maybe has been removed when remove child

	  if (parent) {
	    parent.removeChild(node);
	  }
	}
	function replaceChild(newChild, oldChild, parent) {
	  parent = parent || oldChild.parentNode;
	  parent.replaceChild(newChild, oldChild);
	}
	function insertAfter(node, after, parent) {
	  parent = parent || after.parentNode;
	  var nextSibling = after.nextSibling;

	  if (nextSibling) {
	    // Performance improve when node has been existed before nextSibling
	    if (nextSibling !== node) {
	      insertBefore(node, nextSibling, parent);
	    }
	  } else {
	    appendChild(node, parent);
	  }
	}
	function insertBefore(node, before, parent) {
	  parent = parent || before.parentNode;
	  parent.insertBefore(node, before);
	}
	function addEventListener(node, eventName, eventHandler) {
	  return node.addEventListener(eventName, eventHandler);
	}
	function removeEventListener(node, eventName, eventHandler) {
	  return node.removeEventListener(eventName, eventHandler);
	}
	function removeAttribute(node, propKey) {
	  if (propKey === DANGEROUSLY_SET_INNER_HTML) return;
	  if (propKey === CLASS_NAME) propKey = CLASS;

	  if (propKey in node) {
	    try {
	      // Some node property is readonly when in strict mode
	      node[propKey] = null;
	    } catch (e) {}
	  }

	  node[REMOVE_ATTRIBUTE](propKey);
	}
	function setAttribute(node, propKey, propValue) {
	  // For reduce innerHTML operation to improve performance.
	  if (propKey === DANGEROUSLY_SET_INNER_HTML) {
	    warnUnsupport(DANGEROUSLY_SET_INNER_HTML);
	    return;
	  }

	  if (propKey === CLASS_NAME) propKey = CLASS;

	  if (propKey in node) {
	    try {
	      // Some node property is readonly when in strict mode
	      node[propKey] = propValue;
	    } catch (e) {
	      node[SET_ATTRIBUTE](propKey, propValue);
	    }
	  } else {
	    node[SET_ATTRIBUTE](propKey, propValue);
	  }
	}
	var isDimensionalProp = lib.cached(function (prop) {
	  return !NON_DIMENSIONAL_REG.test(prop);
	});
	function setStyle(node, style, __shouldConvertUnitlessToRpx) {
	  for (var prop in style) {
	    var value = style[prop];
	    var convertedValue = void 0;

	    if (typeof value === 'number' && isDimensionalProp(prop)) {
	      if (__shouldConvertUnitlessToRpx) {
	        convertedValue = value + 'rpx'; // Transfrom rpx to vw

	        convertedValue = lib.convertUnit(convertedValue, prop);
	      } else {
	        convertedValue = value + 'px';
	      }
	    } else {
	      convertedValue = lib.convertUnit(value, prop);
	    } // Support CSS custom properties (variables) like { --main-color: "black" }


	    if (prop[0] === '-' && prop[1] === '-') {
	      // reference: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty.
	      // style.setProperty do not support Camel-Case style properties.
	      node.style.setProperty(prop, convertedValue);
	    } else {
	      node.style[prop] = convertedValue;
	    }
	  }
	}

	function warnUnsupport(message) {
	  console.warn("[DriverKraken]: " + message + " is not supported.");
	}

	exports.addEventListener = addEventListener;
	exports.appendChild = appendChild;
	exports.createBody = createBody;
	exports.createElement = createElement;
	exports.createEmpty = createEmpty;
	exports.createText = createText;
	exports.insertAfter = insertAfter;
	exports.insertBefore = insertBefore;
	exports.removeAttribute = removeAttribute;
	exports.removeChild = removeChild;
	exports.removeEventListener = removeEventListener;
	exports.replaceChild = replaceChild;
	exports.setAttribute = setAttribute;
	exports.setStyle = setStyle;
	exports.updateText = updateText;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=driver-kraken.umd.js.map
