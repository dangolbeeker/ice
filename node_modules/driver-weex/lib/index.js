"use strict";

exports.__esModule = true;
exports.getElementById = getElementById;
exports.createBody = createBody;
exports.createComment = createComment;
exports.createEmpty = createEmpty;
exports.createText = createText;
exports.updateText = updateText;
exports.createElement = createElement;
exports.appendChild = appendChild;
exports.removeChild = removeChild;
exports.replaceChild = replaceChild;
exports.insertAfter = insertAfter;
exports.insertBefore = insertBefore;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.removeAttribute = removeAttribute;
exports.setAttribute = setAttribute;
exports.setStyle = setStyle;
exports.beforeRender = beforeRender;
exports.afterRender = afterRender;

var _styleUnit = require("style-unit");

var STYLE = 'style';
var ID = 'id';
var TEXT = 'text';
var CHILDREN = 'children';
var EVENT_PREFIX_REGEXP = /^on[A-Z]/;
var ARIA_PREFIX_REGEXP = /^aria-/;
var HYPHEN_REGEXP = /\-(\w)/;
var EMPTY = '';

function updateWeexTextValue(node) {
  var value = node.children.map(function (child) {
    // Comment node type
    return child.nodeType === 8 ? child.value : EMPTY;
  }).join(EMPTY);
  node.setAttr('value', value);
}

var nodeMaps = {};
/* global __weex_document__ */

var document = typeof __weex_document__ === 'object' ? __weex_document__ : typeof document === 'object' ? document : null;

function getElementById(id) {
  return nodeMaps[id];
}

function createBody(type, props) {
  if (document.body) {
    return document.body;
  }

  var documentElement = document.documentElement;
  var body = document.createBody(type, props);
  documentElement.appendChild(body);
  return body;
}

function createComment(content) {
  return document.createComment(content);
}

function createEmpty() {
  return createComment(EMPTY);
}

function createText(text) {
  // Use comment node type mock text node
  return createComment(text);
}

function updateText(node, text) {
  node.value = text;
  updateWeexTextValue(node.parentNode);
}

function createElement(type, props) {
  if (props === void 0) {
    props = {};
  }

  var style = {};
  var originStyle = props.style;

  if (originStyle) {
    for (var prop in originStyle) {
      style[prop] = (0, _styleUnit.convertUnit)(originStyle[prop], prop);
    }
  }

  var node = document.createElement(type, {
    style: style
  });

  for (var _prop in props) {
    var value = props[_prop];

    if (_prop === CHILDREN) {
      continue;
    }

    if (value != null) {
      if (_prop === STYLE) {
        continue;
      } else if (EVENT_PREFIX_REGEXP.test(_prop)) {
        var eventName = _prop.slice(2).toLowerCase();

        addEventListener(node, eventName, value, props);
      } else {
        setAttribute(node, _prop, value);
      }
    }
  }

  return node;
}

function appendChild(node, parent) {
  parent.appendChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function removeChild(node, parent) {
  parent = parent || node.parentNode;
  var id = node.attr && node.attr[ID];

  if (id != null) {
    nodeMaps[id] = null;
  }

  parent.removeChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function replaceChild(newChild, oldChild, parent) {
  parent = parent || oldChild.parentNode;
  var previousSibling = oldChild.previousSibling;
  var nextSibling = oldChild.nextSibling;
  removeChild(oldChild, parent);

  if (previousSibling) {
    insertAfter(newChild, previousSibling, parent);
  } else if (nextSibling) {
    insertBefore(newChild, nextSibling, parent);
  } else {
    appendChild(newChild, parent);
  }
}

function insertAfter(node, after, parent) {
  parent = parent || after.parentNode;
  parent.insertAfter(node, after);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function insertBefore(node, before, parent) {
  parent = parent || before.parentNode;
  parent.insertBefore(node, before);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function addEventListener(node, eventName, eventHandler, props) {
  // https://github.com/apache/incubator-weex/blob/master/runtime/vdom/Element.js#L421
  var params = props[eventName + 'EventParams'];
  return node.addEvent(eventName, eventHandler, params);
}

function removeEventListener(node, eventName, eventHandler) {
  return node.removeEvent(eventName, eventHandler);
}

function removeAttribute(node, propKey, propValue) {
  if (propKey == ID) {
    nodeMaps[propValue] = null;
  } // Weex native will crash when pass null value


  return node.setAttr(propKey, undefined, false);
}

function setAttribute(node, propKey, propValue) {
  if (propKey == ID) {
    nodeMaps[propValue] = node;
  } // Weex only support `ariaLabel` format, convert `aria-label` format to camelcase


  if (ARIA_PREFIX_REGEXP.test(propKey)) {
    propKey = propKey.replace(HYPHEN_REGEXP, function (m, p) {
      return p.toUpperCase();
    });
  }

  return node.setAttr(propKey, propValue, false);
}

function setStyle(node, style) {
  for (var prop in style) {
    // Translate `rpx` to weex `px`
    style[prop] = (0, _styleUnit.convertUnit)(style[prop], prop);
  }

  node.setStyles(style);
}

function beforeRender() {
  // Turn off batched updates
  document.open(); // Set `rpx` unit converter

  (0, _styleUnit.setRpx)(1);
}

function afterRender() {
  if (document.listener && document.listener.createFinish) {
    document.listener.createFinish();
  } // Turn on batched updates


  document.close();
}