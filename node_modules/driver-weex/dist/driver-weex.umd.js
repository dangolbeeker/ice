(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.DriverWeex = {}));
}(this, (function (exports) {
	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var lib$1 = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports.isQuickApp = exports.isWeChatMiniProgram = exports.isByteDanceMicroApp = exports.isMiniApp = exports.isKraken = exports.isWeex = exports.isNode = exports.isWeb = void 0;

	  function isUndef(type) {
	    return type === 'undefined';
	  }

	  var isWeb = !isUndef(typeof window) && 'onload' in window;
	  exports.isWeb = isWeb;
	  var isNode = !isUndef(typeof process) && !!(process.versions && process.versions.node);
	  exports.isNode = isNode;
	  var isWeex = !isUndef(typeof WXEnvironment) && WXEnvironment.platform !== 'Web';
	  exports.isWeex = isWeex;
	  var isKraken = !isUndef(typeof __kraken__);
	  exports.isKraken = isKraken;
	  var isMiniApp = !isUndef(typeof my) && my !== null && !isUndef(typeof my.alert);
	  exports.isMiniApp = isMiniApp;
	  var isByteDanceMicroApp = !isUndef(typeof tt) && tt !== null && !isUndef(typeof tt) && !isUndef(tt.showToast); // In wechat mini program, wx.login is a function
	  // In wechat mini propgram webview, there is no wx.login, but exist wx.miniProgram
	  // In bytedance maicro app, there is wx variable.

	  exports.isByteDanceMicroApp = isByteDanceMicroApp;
	  var isWeChatMiniProgram = !isByteDanceMicroApp && !isUndef(typeof wx) && wx !== null && (!isUndef(typeof wx.login) || !isUndef(typeof wx.miniProgram));
	  exports.isWeChatMiniProgram = isWeChatMiniProgram;
	  var isQuickApp = !isUndef(typeof commonjsGlobal) && commonjsGlobal !== null && !isUndef(typeof commonjsGlobal.callNative) && !isWeex;
	  exports.isQuickApp = isQuickApp;
	});

	var lib = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports.isRpx = isRpx;
	  exports.calcRpx = calcRpx;
	  exports.getRpx = getRpx;
	  exports.setRpx = setRpx;
	  exports.getViewportWidth = getViewportWidth;
	  exports.setViewportWidth = setViewportWidth;
	  exports.setDecimalPixelTransformer = setDecimalPixelTransformer;
	  exports.setUnitPrecision = setUnitPrecision;
	  exports.cached = cached;
	  exports.setTargetPlatform = setTargetPlatform;
	  exports.convertUnit = void 0;
	  var RPX_REG = /"[^"]+"|'[^']+'|url\([^\)]+\)|(\d*\.?\d+)rpx/g;

	  var __rpx_coefficient__;

	  var __viewport_width__; // convertUnit method targetPlatform


	  var targetPlatform = lib$1.isWeb ? 'web' : lib$1.isWeex ? 'weex' : ''; // Init toFixed method

	  var unitPrecision = 4;

	  var toFixed = function toFixed(number, precision) {
	    var multiplier = Math.pow(10, precision + 1);
	    var wholeNumber = Math.floor(number * multiplier);
	    return Math.round(wholeNumber / 10) * 10 / multiplier;
	  }; // Dedault decimal px transformer.


	  var decimalPixelTransformer = function decimalPixelTransformer(rpx, $1) {
	    return $1 ? parseFloat(rpx) * getRpx() + 'px' : rpx;
	  }; // Default decimal vw transformer.


	  var decimalVWTransformer = function decimalVWTransformer(rpx, $1) {
	    return $1 ? toFixed(parseFloat(rpx) / (getViewportWidth() / 100), unitPrecision) + 'vw' : rpx;
	  }; // Default 1 rpx to 1 px


	  if (getRpx() === undefined) {
	    setRpx(1);
	  } // Viewport width, default to 750.


	  if (getViewportWidth() === undefined) {
	    setViewportWidth(750);
	  }
	  /**
	   * Is string contains rpx
	   * note: rpx is an alias to rpx
	   * @param {String} str
	   * @returns {Boolean}
	   */


	  function isRpx(str) {
	    return typeof str === 'string' && RPX_REG.test(str);
	  }
	  /**
	   * Calculate rpx
	   * @param {String} str
	   * @returns {String}
	   */


	  function calcRpx(str) {
	    if (targetPlatform === 'web') {
	      // In Web convert rpx to 'vw', same as driver-dom and driver-universal
	      // '375rpx' => '50vw'
	      return str.replace(RPX_REG, decimalVWTransformer);
	    } else if (targetPlatform === 'weex') {
	      // In Weex convert rpx to 'px'
	      // '375rpx' => 375 * px
	      return str.replace(RPX_REG, decimalPixelTransformer);
	    } else {
	      // Other platform return original value, like Mini-App and WX Mini-Program ...
	      // '375rpx' => '375rpx'
	      return str;
	    }
	  }

	  function getRpx() {
	    return __rpx_coefficient__;
	  }

	  function setRpx(rpx) {
	    __rpx_coefficient__ = rpx;
	  }

	  function getViewportWidth() {
	    return __viewport_width__;
	  }

	  function setViewportWidth(viewport) {
	    __viewport_width__ = viewport;
	  }
	  /**
	   * Set a function to transform unit of pixel,
	   * default to passthrough.
	   * @param {Function} transformer function
	   */


	  function setDecimalPixelTransformer(transformer) {
	    decimalPixelTransformer = transformer;
	  }
	  /**
	   * Set unit precision.
	   * @param n {Number} Unit precision, default to 4.
	   */


	  function setUnitPrecision(n) {
	    unitPrecision = n;
	  }
	  /**
	   * Create a cached version of a pure function.
	   * Use the first params as cache key.
	   */


	  function cached(fn) {
	    var cache = new Map();
	    return function cachedFn() {
	      var key = arguments.length <= 0 ? undefined : arguments[0];
	      if (!cache.has(key)) cache.set(key, fn.apply(void 0, arguments));
	      return cache.get(key);
	    };
	  }

	  function setTargetPlatform(platform) {
	    targetPlatform = platform;
	  }
	  /**
	   * Convert rpx.
	   * @param value
	   * @param prop
	   * @param platform
	   * @return {String} Transformed value.
	   */


	  var convertUnit = cached(function (value, prop, platform) {
	    if (platform) {
	      setTargetPlatform(platform);
	    }

	    return isRpx(value) ? calcRpx(value) : value;
	  });
	  exports.convertUnit = convertUnit;
	});

	var STYLE = 'style';
	var ID = 'id';
	var TEXT = 'text';
	var CHILDREN = 'children';
	var EVENT_PREFIX_REGEXP = /^on[A-Z]/;
	var ARIA_PREFIX_REGEXP = /^aria-/;
	var HYPHEN_REGEXP = /\-(\w)/;
	var EMPTY = '';

	function updateWeexTextValue(node) {
	  var value = node.children.map(function (child) {
	    // Comment node type
	    return child.nodeType === 8 ? child.value : EMPTY;
	  }).join(EMPTY);
	  node.setAttr('value', value);
	}

	var nodeMaps = {};
	/* global __weex_document__ */

	var document = typeof __weex_document__ === 'object' ? __weex_document__ : typeof document === 'object' ? document : null;
	function getElementById(id) {
	  return nodeMaps[id];
	}
	function createBody(type, props) {
	  if (document.body) {
	    return document.body;
	  }

	  var documentElement = document.documentElement;
	  var body = document.createBody(type, props);
	  documentElement.appendChild(body);
	  return body;
	}
	function createComment(content) {
	  return document.createComment(content);
	}
	function createEmpty() {
	  return createComment(EMPTY);
	}
	function createText(text) {
	  // Use comment node type mock text node
	  return createComment(text);
	}
	function updateText(node, text) {
	  node.value = text;
	  updateWeexTextValue(node.parentNode);
	}
	function createElement(type, props) {
	  if (props === void 0) {
	    props = {};
	  }

	  var style = {};
	  var originStyle = props.style;

	  if (originStyle) {
	    for (var prop in originStyle) {
	      style[prop] = lib.convertUnit(originStyle[prop], prop);
	    }
	  }

	  var node = document.createElement(type, {
	    style: style
	  });

	  for (var _prop in props) {
	    var value = props[_prop];

	    if (_prop === CHILDREN) {
	      continue;
	    }

	    if (value != null) {
	      if (_prop === STYLE) {
	        continue;
	      } else if (EVENT_PREFIX_REGEXP.test(_prop)) {
	        var eventName = _prop.slice(2).toLowerCase();

	        addEventListener(node, eventName, value, props);
	      } else {
	        setAttribute(node, _prop, value);
	      }
	    }
	  }

	  return node;
	}
	function appendChild(node, parent) {
	  parent.appendChild(node);

	  if (parent.type === TEXT) {
	    updateWeexTextValue(parent);
	  }
	}
	function removeChild(node, parent) {
	  parent = parent || node.parentNode;
	  var id = node.attr && node.attr[ID];

	  if (id != null) {
	    nodeMaps[id] = null;
	  }

	  parent.removeChild(node);

	  if (parent.type === TEXT) {
	    updateWeexTextValue(parent);
	  }
	}
	function replaceChild(newChild, oldChild, parent) {
	  parent = parent || oldChild.parentNode;
	  var previousSibling = oldChild.previousSibling;
	  var nextSibling = oldChild.nextSibling;
	  removeChild(oldChild, parent);

	  if (previousSibling) {
	    insertAfter(newChild, previousSibling, parent);
	  } else if (nextSibling) {
	    insertBefore(newChild, nextSibling, parent);
	  } else {
	    appendChild(newChild, parent);
	  }
	}
	function insertAfter(node, after, parent) {
	  parent = parent || after.parentNode;
	  parent.insertAfter(node, after);

	  if (parent.type === TEXT) {
	    updateWeexTextValue(parent);
	  }
	}
	function insertBefore(node, before, parent) {
	  parent = parent || before.parentNode;
	  parent.insertBefore(node, before);

	  if (parent.type === TEXT) {
	    updateWeexTextValue(parent);
	  }
	}
	function addEventListener(node, eventName, eventHandler, props) {
	  // https://github.com/apache/incubator-weex/blob/master/runtime/vdom/Element.js#L421
	  var params = props[eventName + 'EventParams'];
	  return node.addEvent(eventName, eventHandler, params);
	}
	function removeEventListener(node, eventName, eventHandler) {
	  return node.removeEvent(eventName, eventHandler);
	}
	function removeAttribute(node, propKey, propValue) {
	  if (propKey == ID) {
	    nodeMaps[propValue] = null;
	  } // Weex native will crash when pass null value


	  return node.setAttr(propKey, undefined, false);
	}
	function setAttribute(node, propKey, propValue) {
	  if (propKey == ID) {
	    nodeMaps[propValue] = node;
	  } // Weex only support `ariaLabel` format, convert `aria-label` format to camelcase


	  if (ARIA_PREFIX_REGEXP.test(propKey)) {
	    propKey = propKey.replace(HYPHEN_REGEXP, function (m, p) {
	      return p.toUpperCase();
	    });
	  }

	  return node.setAttr(propKey, propValue, false);
	}
	function setStyle(node, style) {
	  for (var prop in style) {
	    // Translate `rpx` to weex `px`
	    style[prop] = lib.convertUnit(style[prop], prop);
	  }

	  node.setStyles(style);
	}
	function beforeRender() {
	  // Turn off batched updates
	  document.open(); // Set `rpx` unit converter

	  lib.setRpx(1);
	}
	function afterRender() {
	  if (document.listener && document.listener.createFinish) {
	    document.listener.createFinish();
	  } // Turn on batched updates


	  document.close();
	}

	exports.addEventListener = addEventListener;
	exports.afterRender = afterRender;
	exports.appendChild = appendChild;
	exports.beforeRender = beforeRender;
	exports.createBody = createBody;
	exports.createComment = createComment;
	exports.createElement = createElement;
	exports.createEmpty = createEmpty;
	exports.createText = createText;
	exports.getElementById = getElementById;
	exports.insertAfter = insertAfter;
	exports.insertBefore = insertBefore;
	exports.removeAttribute = removeAttribute;
	exports.removeChild = removeChild;
	exports.removeEventListener = removeEventListener;
	exports.replaceChild = replaceChild;
	exports.setAttribute = setAttribute;
	exports.setStyle = setStyle;
	exports.updateText = updateText;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=driver-weex.umd.js.map
